

### Сортировка выбором (C++)
- Как работает: на i‑м шаге ищется минимум на неотсортированном суффиксе и меняется местами с элементом на позиции i; отсортированная часть растёт слева направо.[11]
- Временная сложность: $$O(n^2)$$ в лучшем, среднем и худшем случаях; память $$O(1)$$.[11]
- Почему так: поиск минимума на каждом шаге — это до $$n-i$$ сравнений; сумма по i даёт $$\sum_{i=1}^{n-1}(n-i)=n(n-1)/2=\Theta(n^2)$$, независимо от изначального порядка.[11]

### Пузырьковая сортировка (Python)
- Как работает: многократно проходит по массиву, сравнивая соседей и «всплывая» максимумы в конец; с оптимизацией досрочно останавливается, если обменов не было.[11]
- Временная сложность: худший и средний случаи $$O(n^2)$$, лучший с флагом обмена — $$O(n)$$; память $$O(1)$$.[11]
- Почему так: в худшем нужны порядка $$n$$ проходов по $$n$$ элементов (квадратично); если массив уже отсортирован, первый проход делает 0 обменов и алгоритм завершается за один линейный проход.[11]

### Сортировка вставками (Python)
- Как работает: поддерживает слева отсортированную часть и вставляет следующий элемент на корректную позицию сдвигами вправо.[11]
- Временная сложность: средний/худший случаи $$O(n^2)$$, лучший (почти отсортировано) $$O(n)$$; память $$O(1)$$.[11]
- Почему так: во вставке элемент может пройти назад до начала — до $$O(n)$$ сдвигов на шаг, повторяется для $$n$$ шагов, итого $$O(n^2)$$; при почти отсортированных данных каждый ключ «почти на месте», сдвигов немного, суммарно линейно.[11]

### Сортировка слиянием (C++)
- Как работает: рекурсивно делит массив пополам, сортирует половины и сливает два отсортированных массива в один с линейной по размеру слиянием.[11]
- Временная сложность: всегда $$O(n \log n)$$; память $$O(n)$$ из‑за дополнительных буферов при слиянии.[11]
- Почему так: на каждом уровне рекурсии суммарная работа на слияние — $$O(n)$$, а уровней $$\log_2 n$$, значит суммарно $$O(n \log n)$$ независимо от входа.[11]

### Сортировка Шелла (Python)
- Как работает: выполняет «вставки» не для соседних, а для элементов на расстоянии gap, постепенно уменьшая gap до 1; финальный проход с gap=1 завершает упорядочивание.[11]
- Временная сложность: зависит от последовательности шагов; для простого деления пополам эмпирически около $$O(n^{3/2})$$; память $$O(1)$$.[11]
- Почему так: крупные gap быстро рассеивают большие инверсии, сокращая дистанции элементов; формальный анализ связан с числом инверсий, но для классической последовательности Хиббарда/Седжвика получаются субквадратичные оценки; для простого halving часто приводят оценку порядка $$n^{3/2}$$.[11]

### Быстрая сортировка (Python)
- Как работает: выбирает опорный элемент, переставляет массив так, что слева не больше опорного, справа не меньше, и рекурсивно сортирует подмассивы; в реализации — схема разбиения Ломуто.[11]
- Временная сложность: средний $$O(n \log n)$$, худший $$O(n^2)$$; память $$O(\log n)$$ на стек (в среднем).[11]
- Почему так: средняя глубина рекурсии при удачном разбиении — $$\Theta(\log n)$$, а на каждом уровне суммарно $$O(n)$$ сравнений; при патологическом выборе опорного (например, уже отсортированный массив с pivot=последний) глубина становится $$\Theta(n)$$, давая $$\Theta(n^2)$$.[11]

### Пирамидальная сортировка (C++)
- Как работает: строит max‑heap, затем итеративно меняет корень (максимум) с последним элементом и «просеивает» новый корень вниз для восстановления кучи.[11]
- Временная сложность: всегда $$O(n \log n)$$; память $$O(1)$$.[11]
- Почему так: построение кучи — $$O(n)$$ благодаря суммарной стоимости просеиваний, далее выполняется $$n-1$$ извлечений максимума по $$O(\log n)$$ каждое (высота кучи), суммарно $$O(n \log n)$$.[11]

### Линейный поиск (Python)
- Как работает: последовательно сравнивает целевое значение с каждым элементом до совпадения или конца массива.[11]
- Временная сложность: средний/худший $$O(n)$$, лучший $$O(1)$$; память $$O(1)$$.[11]
- Почему так: в худшем проверяются все $$n$$ элементов, в лучшем цель находится на первом месте; нет структуры, позволяющей «перепрыгивать» позиции.[11]

### Бинарный поиск (Python)
- Как работает: на отсортированном массиве сравнивает с серединой и отбрасывает половину диапазона, повторяя до нахождения или пустого интервала.[11]
- Временная сложность: $$O(\log n)$$; память $$O(1)$$ в итеративной форме.[11]
- Почему так: каждый шаг делит оставшийся интервал размера $$m$$ примерно пополам ($$m \to m/2$$), число шагов до размера 1 равно $$\lfloor \log_2 n \rfloor + 1$$.[11]

### Интерполяционный поиск (C++)
- Как работает: на отсортированном и примерно равномерно распределённом массиве оценивает позицию по линейной интерполяции значений, после чего сужает поиск влево/вправо и повторяет.[11]
- Временная сложность: лучшее $$O(\log \log n)$$ при равномерном распределении, худшее $$O(n)$$; память $$O(1)$$.[11]
- Почему так: при равномерности оценка позиции близка к цели, и диапазон сокращается существенно быстрее, чем вдвое, приводя к двойному логарифму; при плохом распределении оценка может «ошибаться», и сокращение будет неэффективным до линейного.[11]

### Поиск по Фибоначчи (Python)
- Как работает: на отсортированном массиве подбирает минимальное число Фибоначчи $$F_m \ge n$$ и использует последовательные числа $$F_{m-1}, F_{m-2}$$ для выбора индексов сравнения, уменьшая «окно» по шаблону Фибоначчи.[11]
- Временная сложность: $$O(\log n)$$; память $$O(1)$$.[11]
- Почему так: числа Фибоначчи растут экспоненциально ($$F_k \approx \varphi^k$$), поэтому количество шагов, необходимых чтобы «спуститься» от $$F_m$$ до единицы, пропорционально $$m \in \Theta(\log n)$$.[11]



[1](https://habr.com/ru/articles/422085/)
[2](https://neerc.ifmo.ru/wiki/index.php?title=%D0%A1%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0_%D0%B2%D1%8B%D0%B1%D0%BE%D1%80%D0%BE%D0%BC)
[3](https://younglinux.info/algorithm/sort_min)
[4](https://foxford.ru/wiki/informatika/sortirovka-vyborom)
[5](https://www.youtube.com/watch?v=KZxP5JqtKKA)
[6](http://aliev.me/runestone/SortSearch/TheSelectionSort.html)
[7](https://javarush.com/quests/lectures/questharvardcs50.level03.lecture08)
[8](https://blog.skillfactory.ru/sorting-algorithm/)
[9](https://cs.mipt.ru/algo/lessons/lab8.html)
[10](https://ru.algorithmica.org/cs/sorting/selection/)
[11](https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/120399756/81e067f8-84d3-490e-869a-9145323c9923/Metodicheskie_rekomendatsii_dlia_vypolneniia_laboratornykh_rabot_3_1.pdf)
